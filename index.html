<!DOCTYPE html><html><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content=""><meta name="keywords" content=""><meta name="author" content="PoetryWanderer,undefined"><meta name="copyright" content="PoetryWanderer"><title>Hexo</title><link rel="shortcut icon" href="/my-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.5.6"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css?version=1.5.6"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="author-info"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">PoetryWanderer</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">2</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">4</span></a></div></div></div><nav class="no-bg" id="nav" style="background-image: url(true)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Hexo</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="site-info"><div id="site-title">Hexo</div><div id="site-sub-title"></div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/2018/11/22/Off-line Programming 离线编程 简明教程/">Off-line Programming 离线编程 简明教程</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-11-22</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/off-line-programming/">off-line programming</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/SolidWorks二次开发/">SolidWorks二次开发</a></span><div class="content"><h1 id="Off-line-Programming-离线编程-简明教程"><a href="#Off-line-Programming-离线编程-简明教程" class="headerlink" title="Off-line Programming 离线编程 简明教程"></a>Off-line Programming 离线编程 简明教程</h1><h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>最近接触了一些离线编程的相关工作（off-line programming），要求基于SolidWorks进行二次开发，开发平台选择Visual Studio 2010</p>
<h3 id="理论回顾"><a href="#理论回顾" class="headerlink" title="理论回顾"></a>理论回顾</h3><p>​    机器人焊接离线编程的主要任务是：分析待焊件SolidWorks模型，从模型中提取焊接路径位置姿态信息，对提取的信息作处理。此时，需要对焊接路径进行离散，通过矩阵变换获得机器人焊枪运动相关信息。这实际上属于自动编程的范畴，相对于手工示教编程，自动编程是从已经建立好的工件SolidWorks模型中提取得到集合信息，而不是从实物中提取，这样便可以通过编程控制离散的精度，对焊接路径进行合理的离散。</p>
<h3 id="正式开始"><a href="#正式开始" class="headerlink" title="正式开始"></a>正式开始</h3><h5 id="版本选择："><a href="#版本选择：" class="headerlink" title="版本选择："></a>版本选择：</h5><p>​    由于是基于SolidWorks进行开发，利用SolidWorks本身提供的SolidWorks API SDK.msi（可在SolidWorks的安装文件夹下api目录中找到）二次开发工具，点击安装后可在visual studio中建立工程进行开发。由于SolidWorks API SDK.msi的版本问题，因此<strong>注意</strong>电脑安装的SolidWorks与利用的msi文件版本保持一致。同时，经过实践发现，利用SolidWorks新建VC++项目时，VS2015总是失败，而换回VS2010可以。</p>
<p>​    SolidWorks API SDK.msi安装过程及如何在VS2010中利用SolidWorks新建VC++项目 看<a href="https://github.com/poetrywanderer/Off-line-Programming/blob/master/SOLIDWORKS%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91.pdf" target="_blank" rel="noopener">这里</a></p>
<h5 id="软件开发过程："><a href="#软件开发过程：" class="headerlink" title="软件开发过程："></a>软件开发过程：</h5><p>​    开发过程与正常的基于MFC框架开发软件相似，MFC简明教程可以看<a href="https://blog.csdn.net/hubojing/article/details/70306414?locationNum=13&amp;fps=1" target="_blank" rel="noopener">这里</a>，当然现在很多人说MFC已经落伍，也不知道真假。</p>
<p>​    我开发的软件界面：</p>
<p><img src="./images/1.png" alt="基于solidworks的离线编程软件开发"></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2018/05/02/深度学习之零部件缺陷检测/">深度学习之零部件缺陷检测</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-05-02</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/缺陷检测/">缺陷检测</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/FCN/">FCN</a></span><div class="content"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​    最近实验室的一个项目是工业生产中零部件缺陷检测的任务，在为期两周的时间里，利用之前深度学习的理论，从搭建网络开始，期间先后尝试了分类和检测网络，最终达到了较高的准确率。现将过程中一些心得体会记录如下。</p>
<h2 id="0-任务分析"><a href="#0-任务分析" class="headerlink" title="0 任务分析"></a>0 任务分析</h2><p>​    汽车零部件在生产制造过程中，由于制造工业问题，其表面难免会留下一些多余的如铝屑等。项目任务就是利用采集到的零件图片，识别出其中含有类似缺陷的个体，其中要尽可能降低漏检率，可以有一定的误检。</p>
<p>考虑到原始图片多大，而我们并不关心零件以外的其他信息，因此我们通过人为地设定ROI，尽可能地减小其他多余无用信息，提高特征学习的效率。</p>
<p>下图为三种典型零件外部缺陷：</p>
<p><img src="./images/detect.jpg" alt="Fig.1 detect"></p>
<p>缺陷特征：</p>
<ul>
<li>缺陷位置：顶部螺纹处、底部孔隙处</li>
<li>形状：长条状、短片状</li>
<li>大小：大小都有</li>
<li>分析：由于孔隙位置的随机性，底部缺陷的识别应该更加复杂。而上部分相对简单，因此主要针对底部进行模型调试。</li>
</ul>
<h2 id="1-小试牛刀——图像分类网络"><a href="#1-小试牛刀——图像分类网络" class="headerlink" title="1 小试牛刀——图像分类网络"></a>1 小试牛刀——图像分类网络</h2><p><strong>考虑1</strong>：缺陷情况较为简单，准备先用分类网络进行识别，初步采用基于VGG的二分类模型。</p>
<p><strong>考虑2</strong>：模型输入图片选择不同的ROI区域，可能会影响模型特征提取效果，在图2中分别为ROI Area1、ROI Area2、Patch。</p>
<h4 id="1-1-数据集-dataset"><a href="#1-1-数据集-dataset" class="headerlink" title="1.1 数据集(dataset)"></a>1.1 数据集(dataset)</h4><ul>
<li><p>思路1：将零件部分作为模型输入。</p>
</li>
<li><p>思路2：为了进一步提高模型的学习效率，先根据缺陷的位置分别设定了两部分的ROI分别进行学习，这里主要调试特征相对复杂的底部缺陷识别模型。</p>
</li>
<li><p>思路3：由于含缺陷的零件较少，实际采集到的图片并不能达到数据集的要求，因此需要对图片进行数据扩充(data augmentation)，一般在做这类缺陷检测的任务时，因为缺陷往往只存在于图片的某个局部区域，常常将图片划分为不同的patches，如图2，此时数据集扩充了5倍。</p>
<p>需要注意的是，patch 大小的选择应满足：存在一个或多个patch刚好能够框住局部所有缺陷。如果选的太小，会大大损失缺陷特征，导致无法收敛。 </p>
</li>
</ul>
<p><img src="./images/patch.jpg" alt="Fig.2 patch"></p>
<h4 id="1-2-模型结构及训练日志"><a href="#1-2-模型结构及训练日志" class="headerlink" title="1.2 模型结构及训练日志"></a>1.2 模型结构及训练日志</h4><ul>
<li><h5 id="模型结构："><a href="#模型结构：" class="headerlink" title="模型结构："></a>模型结构：</h5><pre><code>刚开始想采用VGG16，但是考虑到此类缺陷特征不是特别复杂，就考虑使用简单点的AlexNet
</code></pre></li>
<li><h5 id="测试结果："><a href="#测试结果：" class="headerlink" title="测试结果："></a>测试结果：</h5><p>   在测试过程中，采用三种思路的数据集分别作为输入，其测试集正确率依次为思路1&lt;思路3&lt;思路2。如图3所示。其中橙色曲线代表训练集，蓝色曲线代表验证集。</p>
</li>
</ul>
<p><img src="./images/curve1.jpg" alt="Fig.3-1 curve1"></p>
<p><img src="./images/curve2.jpg" alt="Fig.3-2 curve2"></p>
<p><img src="./images/curve3.jpg" alt="Fig.3-3 curve3"></p>
<ul>
<li><h5 id="过程分析："><a href="#过程分析：" class="headerlink" title="过程分析："></a>过程分析：</h5><p>   在训练过程中，遵循着ROI1–ROI2–ROI2-patch的顺序，显然ROI2区域作为输入的测试正确率是最高的，但是依然没有达到要求。</p>
<p>   而ROI1和ROI2-patch作为输入时，虽然训练模型都很快收敛，但是测试集正确率很低，说明模型没有正确学习到缺陷的特征，分析原因我认为可能是：</p>
<ul>
<li><p>缺陷特征的显著性：</p>
<ul>
<li><p>对于ROI1来说，缺陷特征目标面积占比较小，特征往往集中在某一小部分区域内，模型可能将其他的无关特征学习的过多；</p>
</li>
<li><p>而对于ROI2-patch来说，缺陷特征目标面积占比确实增大了不少，但是当输入patch小到一定程度的时候，同时图像的清晰度也会大大下降，往往人都很难分辨出缺陷和背景。</p>
</li>
<li><p>因此，这里需要做一个trade-off，即在缺陷和背景清晰可分的情况下，缺陷目标面积占比越大，越有利于模型特征学习。</p>
</li>
</ul>
</li>
<li><p>过拟合问题：</p>
<p>解决模型过拟合，主要考虑三个方面：</p>
<ul>
<li><p>增加数据集</p>
<p>思考是否存在这些问题：数据集过小，含缺陷与不含缺陷的图像比例悬殊，数据集和测试集的数据分布不一致，数据集缺陷类别过于单一等。</p>
<p>解决方案可以采用数据增强（data augmentation）</p>
</li>
<li><p>增加dropout层</p>
</li>
<li><p>正则化操作<br> 一般采用L2正则项，可以起到使得参数w变小加剧的效果，一个通俗的理解便是：更小的参数值w意味着模型的复杂度更低，对训练数据的拟合刚刚好，不会过分拟合训练数据，从而使得不会过拟合，以提高模型的泛化能力。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><h5 id="头脑风暴："><a href="#头脑风暴：" class="headerlink" title="头脑风暴："></a>头脑风暴：</h5><p>   关于如何改进，考虑到分成patch后的图像分辨率低，特征不明显，如果在输入模型之前对其进行一次预处理增强特征，应该能在原有的基础上再次提高分类模型学习效果。</p>
</li>
<li><h5 id="内心独白："><a href="#内心独白：" class="headerlink" title="内心独白："></a>内心独白：</h5><p>   在训练过程中，由于是第一次系统的从头开始做一个项目，从学着如何制作数据集开始，如何搭建模型，如何将结果整理输出到Tensorboard，再到如何根据结果进行调参，如何选择不同的模块（包括权重初始化的选择：一定要用Xavier啊，什么时候用正则化，BN层使用原则，输入图像进行怎样的预处理，损失函数的选用等），经过一个完整流程的洗礼，渐渐地抓住了一些东西，嗯感觉还不错。</p>
</li>
</ul>
<h2 id="2-柳暗花明——像素分类FCN网络"><a href="#2-柳暗花明——像素分类FCN网络" class="headerlink" title="2 柳暗花明——像素分类FCN网络"></a>2 柳暗花明——像素分类FCN网络</h2><p>前言：课题组另一个方向采用FCN网络做了另一类小缺陷的识别，效果很不错，因此可不可以将FCN网络运用到我们这个项目来呢？</p>
<h6 id="考虑1："><a href="#考虑1：" class="headerlink" title="考虑1："></a>考虑1：</h6><p><a href="https://blog.csdn.net/happyer88/article/details/47205839" target="_blank" rel="noopener">FCN</a>是目标检测的网络，而我们这里只需要确定图像中有无缺陷，不需要检测缺陷的具体位置和尺寸大小。两个看似不同的领域，但正是这种思路的转变，有时候就是能够取得意想不到的效果呢？</p>
<h6 id="考虑2："><a href="#考虑2：" class="headerlink" title="考虑2："></a>考虑2：</h6><p>图像分类网络最大的问题在于，标记时只区分了0/1（类别信息），当缺陷特征不明显时，网络往往无法准确寻找到缺陷的大小和位置信息，分类的效果自然较差。</p>
<p>目标检测网络在标记时会给出图像所在的位置、尺寸信息，消除了网络自己在学习这部分特征时的误差，而只需要学习类别特征即可，识别效果应该会更好。</p>
<h4 id="2-1-数据集-Dataset"><a href="#2-1-数据集-Dataset" class="headerlink" title="2.1 数据集(Dataset)"></a>2.1 数据集(Dataset)</h4><p>利用<a href="https://github.com/wkentaro/labelme" target="_blank" rel="noopener">Labelme</a>软件对零件缺陷进行标注，标注过程如图4所示。</p>
<p><img src="./images/fig4.jpg" alt="Fig.4"></p>
<h4 id="2-2-FCN模型结构（Model-Structures）"><a href="#2-2-FCN模型结构（Model-Structures）" class="headerlink" title="2.2 FCN模型结构（Model Structures）"></a>2.2 FCN模型结构（Model Structures）</h4><ul>
<li>结构1：</li>
</ul>
<p><img src="./images/fig5.jpg" alt="Fig.5"><br>  说明：网络采用了两次pool操作，即两次downsampling，图像尺寸变为1/4，因此需要进行一次upsampling。</p>
<h4 id="2-3-模型训练日志"><a href="#2-3-模型训练日志" class="headerlink" title="2.3 模型训练日志"></a>2.3 模型训练日志</h4><p>考虑到模型结构的影响，总共对7种模型进行了测试。</p>
<h5 id="1-模型结构"><a href="#1-模型结构" class="headerlink" title="1.模型结构"></a>1.模型结构</h5><p><img src="./images/model_structure.jpg" alt="Fig.6 model_structure"></p>
<h5 id="2-训练过程"><a href="#2-训练过程" class="headerlink" title="2.训练过程"></a>2.训练过程</h5><p>测试结果表明，model1、2、6的结果相当，在迭代30000次左右收敛。</p>
<p><img src="./images/FCN-curve.jpg" alt="Fig.7 FCN-curve"></p>
<h4 id="2-4-图像后处理"><a href="#2-4-图像后处理" class="headerlink" title="2.4 图像后处理"></a>2.4 图像后处理</h4><p>由于输出图显示较为粗糙，虽然识别除了缺陷但是存在着多处小的噪点，进行一步后处理可显著提高模型预测的精度。如下图所示：</p>
<p><img src="./images/after-process.jpg" alt="Fig.8 after-process"></p>
<p>下图为多个缺陷图片的检测结果：</p>
<p><img src="./images/FCN-result.jpg" alt="Fig.9 FCN-result"></p>
<h4 id="2-5-结果分析讨论"><a href="#2-5-结果分析讨论" class="headerlink" title="2.5 结果分析讨论"></a>2.5 结果分析讨论</h4><p>总的来说，FCN网络的检测结果达到了我们所要求的精度，没想到一个思路的转变就能取得结果的质变，更多的细节分析后续带来。。。</p>
</div><hr></div><nav id="pagination"><div class="pagination"><span class="page-number current">1</span></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2018 By PoetryWanderer</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.5.6"></script><script src="/js/fancybox.js?version=1.5.6"></script><script src="/js/sidebar.js?version=1.5.6"></script><script src="/js/copy.js?version=1.5.6"></script><script src="/js/fireworks.js?version=1.5.6"></script><script src="/js/transition.js?version=1.5.6"></script><script src="/js/scroll.js?version=1.5.6"></script><script src="/js/head.js?version=1.5.6"></script></body></html>